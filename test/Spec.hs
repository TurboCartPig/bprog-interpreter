-- | The tests implemented here are not identical to the official tests,
-- but they are equivilant in terms of what they test.
module Main where

import           Data.Maybe      (listToMaybe)
import           Eval            (eval)
import           GHC.Base
import           Lib             (interpret)
import           Parser          (parse)
import           Test.DocTest    (doctest)
import           Test.Hspec      (Spec, describe, hspec, it)
import           Test.QuickCheck
import           Types

-- TODO: Implement property tests that test that all primitives parse into their respective Value.

-- | `it` specialized for parser.
pit :: String -> String -> Value -> Spec
pit text input expected = do
  it text $ do
    (parse input >>= listToMaybe) == Just (Val expected)

-- | `it` specialized for interpret.
iit :: String -> Value -> Spec
iit input expected = do
  it input $ do
    interpret input == Just expected

-- | Property tests parsing ints and floats.
-- Here are the reasons we can not property test the other primitives:
-- * Bools just don't make sense, we test both already.
-- * Strings can contain whitespace, or be empty, both of which I don't handle in the parser.
-- * Quotations can not be generated by QuickCheck. Not in a way that actually tests anything anyway.
-- * Lists might be possble, but I imagine that it's tricky.
parsePropertySpec :: Spec
parsePropertySpec = do
  describe "parser" $ do
    it "parses ints" $ do
      property $ \x -> (parse . show $ x) == Just [Val (VInt x)]
    it "parses floats" $ do
      property $ \x -> (parse . show $ x) == Just [Val (VFloat x)]

-- | Some basic unit tests for parsing primitive values.
parseSpec :: Spec
parseSpec = do
  describe "parser" $ do
    pit "parses an int" "1"
      (VInt 1)
    pit "parses a negative int" "-1"
      (VInt (-1))
    pit "parses a float" "1.2"
      (VFloat 1.2)
    pit "parses a negative float" "-1.2"
      (VFloat (-1.2))
    pit "parses true as bool" "true"
      (VBool True)
    pit "parses false as bool" "false"
      (VBool False)
    pit "parses a string" "\"this is a string\""
      (VString "this is a string")
    pit "parses a list" "[ 1 2 3 ]"
      (VList [VInt 1, VInt 2, VInt 3])
    pit "parses a nested list" "[ [ 1 ] 2 [ 3 ] ]"
      (VList [VList [VInt 1], VInt 2, VList [VInt 3]])
    pit "parses a quotation" "{ 1 2 }"
      (VQuotation [Val (VInt 1), Val (VInt 2)])
    pit "parses a nested quotation" "{ 1 2 { 3 } }"
      (VQuotation [Val (VInt 1), Val (VInt 2), Val (VQuotation [Val (VInt 3)])])

interpretSpec :: Spec
interpretSpec = do
  describe "interpreter" $ do
    describe "interprets literals" $ do
      iit "1"
        (VInt 1)
      iit "1.1"
        (VFloat 1.1)
    describe "interprets simple arithmetic" $ do
      iit "1 1 +"
        (VInt 2)
      iit "10 20 *"
        (VInt 200)
      iit "10 2 div"
        (VInt 5)
      iit "20 2 /"
        (VFloat 10.0)
    describe "interprets arithmetic with type coercion" $ do
      iit "1 1.0 +"
        (VFloat 2.0)
      iit "10 20.0 *"
        (VFloat 200.0)
      iit "20 2.0 div"
        (VInt 10)
      iit "20.0 2.0 div"
        (VInt 10)
    describe "bool operations" $ do
      iit "false false &&"
        (VBool False)
      iit "false true ||"
        (VBool True)
      iit "false not"
        (VBool True)
      iit "true not"
        (VBool False)
    describe "comparisons" $ do
      iit "20 10 <"
        (VBool False)
      iit "20 10 >"
        (VBool True)
      iit "20 10.0 >"
        (VBool True)
      iit "20 20.0 >"
        (VBool False)
      iit "10 10 =="
        (VBool True)
      iit "10 10.0 =="
        (VBool True)
      iit "true true =="
        (VBool True)
      iit "true 40 40 == =="
        (VBool True)
      iit "\"abba\" \"abba\" =="
        (VBool True)
      iit "[ ] [ ] =="
        (VBool True)
      iit "[ 1 2 ] [ 1 2 ] =="
        (VBool True)
      iit "[ [ ] ] [ [ ] ] =="
        (VBool True)
    describe "stack operations" $ do
      iit "10 20 swp pop"
        (VInt 20)
      iit "10 dup dup + swp pop"
        (VInt 20)
      iit "10 20 swp dup + div"
        (VInt 1)
    describe "length" $ do
      iit "\"hello\" length"
        (VInt 5)
      iit "\"hello world\" length"
        (VInt 11)
      iit "[ 1 2 3 [ ] ] length"
        (VInt 4)
      iit "{ 10 20 + } length"
        (VInt 3)
    describe "string parsing" $ do
      iit "\"12\" parseInteger"
        (VInt 12)
      iit "\"12.34\" parseFloat"
        (VFloat 12.34)
      iit "\"adam bob charlie\" words"
        (VList [VString "adam", VString "bob", VString "charlie"])
    describe "lists" $ do
      iit "[ 1 2 3 ]"
        (VList [VInt 1, VInt 2, VInt 3])
      iit "[ 1 \"bob\" ]"
        (VList [VInt 1, VString "bob"])
      iit "[ 1 2 ] empty"
        (VBool False)
      iit "[ 1 2 3 ] head"
        (VInt 1)
      iit "[ 1 2 3 ] length"
        (VInt 3)
      iit "[ 1 2 3 ] tail"
        (VList [VInt 2, VInt 3])
      iit "1 [ ] cons"
        (VList [VInt 1])
      iit "1 [ 2 3 ] cons"
        (VList [VInt 1, VInt 2, VInt 3])
      iit "[ 1 ] [ 2 3 ] append"
        (VList [VInt 1, VInt 2, VInt 3])
      iit "[ 1 2 ] [ ] append"
        (VList [VInt 1, VInt 2])
      iit "[ ] [ 1 2 ] append"
        (VList [VInt 1, VInt 2])
      iit "[ 1 ] [ 2 3 ] cons"
        (VList [VList [VInt 1], VInt 2, VInt 3])
    -- describe "list quotations" $ do
    -- describe "assignments" $ do
    describe "quotations" $ do
      iit "{ 20 10 + } exec"
        (VInt 30)
      iit "20 { 10 + } exec"
        (VInt 30)
      iit "20 10 { + } exec"
        (VInt 30)
      iit "{ { 20 10 + } exec } exec"
        (VInt 30)
      iit "{ { 20 10 + } exec 20 + } exec"
        (VInt 50)
    -- describe "ifs" $ do
    -- describe "if without quotations" $ do
    -- describe "times" $ do
    -- describe "loop" $ do
    -- describe "some programs" $ do

main :: IO ()
main = do
  putStrLn "DocTests:"
  doctest ["app", "src"]

  putStrLn "Unit tests:"
  hspec parseSpec
  hspec parsePropertySpec
  hspec interpretSpec
